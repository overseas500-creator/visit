{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/MJD8/OneDrive/Desktop/projects/visit/src/app/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { db } from '@/lib/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function sendOTP(mobileNumber: string) {\r\n    // 1. Generate 4-digit code\r\n    const code = Math.floor(1000 + Math.random() * 9000).toString();\r\n\r\n    // 2. Save to DB with expiration (5 mins)\r\n    const expiresAt = new Date(Date.now() + 5 * 60 * 1000).toISOString();\r\n\r\n    if (process.env.NEXT_PHASE !== 'phase-production-build') {\r\n        const stmt = db.prepare(`\r\n        INSERT OR REPLACE INTO otp_codes (mobile_number, code, expires_at)\r\n        VALUES (?, ?, ?)\r\n      `);\r\n        stmt.run(mobileNumber, code, expiresAt);\r\n    }\r\n\r\n    // 3. Send SMS\r\n    try {\r\n        // Fetch SMS settings from DB\r\n        const settingsStmt = db.prepare(\"SELECT key, value FROM settings WHERE key IN ('sms_api_key', 'sms_sender_name')\");\r\n        const settings = settingsStmt.all() as { key: string; value: string }[];\r\n        const settingsMap = settings.reduce((acc, curr) => ({ ...acc, [curr.key]: curr.value }), {} as Record<string, string>);\r\n\r\n        const apiKey = settingsMap['sms_api_key'] || 'Cg4W16D1N9ckkBXhUafP0gS19XB6ZujmMNC5rtkt1e2e6f1c';\r\n        const senderName = settingsMap['sms_sender_name'] || 'School1';\r\n\r\n        const message = `رمز التحقق: ${code}`;\r\n\r\n        // Format number: remove leading 0, prefix with 966\r\n        // 0501234567 -> 966501234567\r\n        let number = mobileNumber.trim();\r\n        if (number.startsWith('0')) {\r\n            number = '966' + number.substring(1);\r\n        } else if (number.startsWith('5')) {\r\n            number = '966' + number;\r\n        }\r\n\r\n        console.log(`[SMS] Sending to ${number}...`);\r\n\r\n        const response = await fetch('https://app.mobile.net.sa/api/v1/send', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${apiKey}`,\r\n                'Content-Type': 'application/json',\r\n                'Accept': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                number: number,\r\n                senderName: senderName, // Using default/example sender name to ensure delivery\r\n                sendAtOption: \"Now\",\r\n                messageBody: message,\r\n                allow_duplicate: true\r\n            })\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text();\r\n            console.error('SMS API Error:', errorText);\r\n            // Try to parse JSON error if possible\r\n            try {\r\n                const jsonError = JSON.parse(errorText);\r\n                return { success: false, error: `فشل المزود: ${jsonError.message || JSON.stringify(jsonError)}` };\r\n            } catch {\r\n                return { success: false, error: `فشل المزود: ${errorText.substring(0, 100)}` };\r\n            }\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Failed to send SMS:', error);\r\n        return { success: false, error: `فشل إرسال الرسالة: ${error.message}` };\r\n    }\r\n}\r\n\r\nexport async function verifyOTP(mobileNumber: string, code: string) {\r\n    const stmt = db.prepare('SELECT code, expires_at FROM otp_codes WHERE mobile_number = ?');\r\n    const result = stmt.get(mobileNumber) as { code: string; expires_at: string };\r\n\r\n    if (!result) return { success: false, error: 'رقم الجوال غير معروف' };\r\n\r\n    if (result.code !== code) return { success: false, error: 'رمز التحقق غير صحيح' };\r\n\r\n    if (new Date(result.expires_at) < new Date()) {\r\n        return { success: false, error: 'انتهت صلاحية الرمز' };\r\n    }\r\n\r\n    // Clear OTP after success\r\n    db.prepare('DELETE FROM otp_codes WHERE mobile_number = ?').run(mobileNumber);\r\n\r\n    return { success: true };\r\n}\r\n\r\nexport interface VisitorData {\r\n    name: string;\r\n    idNumber: string;\r\n    mobileNumber: string;\r\n    purpose: string;\r\n    signature: string; // Base64\r\n}\r\n\r\nexport async function submitVisitor(data: VisitorData) {\r\n    const stmt = db.prepare(`\r\n    INSERT INTO visitors (name, id_number, mobile_number, visit_date, visit_time, purpose, signature)\r\n    VALUES (?, ?, ?, ?, ?, ?, ?)\r\n  `);\r\n\r\n    const now = new Date();\r\n    const date = now.toISOString().split('T')[0]; // YYYY-MM-DD\r\n    const time = now.toLocaleTimeString('en-US', { hour12: false });\r\n\r\n    try {\r\n        const result = stmt.run(\r\n            data.name,\r\n            data.idNumber,\r\n            data.mobileNumber,\r\n            date,\r\n            time,\r\n            data.purpose,\r\n            data.signature\r\n        );\r\n\r\n        revalidatePath('/');\r\n        return { success: true, id: result.lastInsertRowid };\r\n    } catch (error) {\r\n        console.error('Failed to save visitor:', error);\r\n        return { success: false, error: 'Failed to save data' };\r\n    }\r\n}\r\n\r\nexport async function getVisitors(date?: string) {\r\n    // If no date provided, default to today's date\r\n    const targetDate = date || new Date().toISOString().split('T')[0];\r\n\r\n    try {\r\n        const stmt = db.prepare('SELECT * FROM visitors WHERE visit_date = ? ORDER BY id DESC');\r\n        const visitors = stmt.all(targetDate) as any[]; // Type as needed\r\n        return { success: true, data: visitors };\r\n    } catch (error) {\r\n        console.error('Failed to get visitors:', error);\r\n        return { success: false, error: 'Failed to fetch data' };\r\n    }\r\n}\r\n\r\nexport async function getSchoolInfo() {\r\n    try {\r\n        const keys = ['school_country', 'school_ministry', 'school_directorate', 'school_name', 'sms_api_key', 'sms_sender_name', 'enable_otp'];\r\n        const placeholders = keys.map(() => '?').join(',');\r\n        const stmt = db.prepare(`SELECT key, value FROM settings WHERE key IN (${placeholders})`);\r\n        const results = stmt.all(...keys) as { key: string; value: string }[];\r\n\r\n        const info: Record<string, string> = {};\r\n        results.forEach(r => {\r\n            info[r.key] = r.value;\r\n        });\r\n\r\n        return { success: true, data: info };\r\n    } catch (error) {\r\n        console.error('Failed to get school info:', error);\r\n        return { success: false, error: 'Failed to fetch info' };\r\n    }\r\n}\r\n\r\n// Existing import modification\r\nimport * as XLSX from 'xlsx';\r\n\r\n// ... (keep existing functions, I will just append new ones for now, but better to do it cleanly)\r\n\r\nexport async function importStudents(formData: FormData) {\r\n    const file = formData.get('file') as File;\r\n    if (!file) return { success: false, error: 'No file uploaded' };\r\n\r\n    try {\r\n        const bytes = await file.arrayBuffer();\r\n        const buffer = Buffer.from(bytes);\r\n        const workbook = XLSX.read(buffer, { type: 'buffer' });\r\n        const sheetName = workbook.SheetNames[0];\r\n        const sheet = workbook.Sheets[sheetName];\r\n        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });\r\n\r\n        // Expected columns: Name, Grade, Class, ID Number, Mobile\r\n        // Assuming header row exists, start from index 1. If not, check data.\r\n        // Let's assume row 0 is header.\r\n\r\n        const stmt = db.prepare(`\r\n            INSERT INTO students (name, grade, class_name, id_number, mobile_number)\r\n            VALUES (?, ?, ?, ?, ?)\r\n        `);\r\n\r\n        // Use transaction for bulk insert\r\n        const insertMany = db.transaction((rows) => {\r\n            for (const row of rows) {\r\n                // row is array [Name, Grade, Class, ID, Mobile]\r\n                // Be careful with index if header exists\r\n                if (!row[0] || !row[3]) continue; // Skip empty rows or missing mandatory fields\r\n                try {\r\n                    stmt.run(row[0], row[1], row[2], String(row[3]), String(row[4]));\r\n                } catch (e) {\r\n                    console.log('Skipping duplicate or invalid row:', row);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Skip first row (headers)\r\n        const dataRows = jsonData.slice(1);\r\n        insertMany(dataRows);\r\n\r\n        return { success: true, count: dataRows.length };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Failed to process file' };\r\n    }\r\n}\r\n\r\n// ... (existing code)\r\n\r\nexport async function getAllStudents() {\r\n    try {\r\n        const stmt = db.prepare('SELECT * FROM students ORDER BY grade, class_name, name');\r\n        const students = stmt.all();\r\n        return { success: true, data: students };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Failed to fetch students' };\r\n    }\r\n}\r\n\r\nexport async function searchStudents(filters: { name?: string, grade?: string, class_name?: string, id_number?: string, mobile_number?: string }) {\r\n    try {\r\n        let sql = 'SELECT * FROM students WHERE 1=1';\r\n        const params: any[] = [];\r\n\r\n        if (filters.name?.trim()) {\r\n            sql += ' AND name LIKE ?';\r\n            params.push(`%${filters.name.trim()}%`);\r\n        }\r\n        if (filters.grade?.trim()) {\r\n            sql += ' AND grade LIKE ?';\r\n            params.push(`%${filters.grade.trim()}%`);\r\n        }\r\n        if (filters.class_name?.trim()) {\r\n            sql += ' AND class_name LIKE ?';\r\n            params.push(`%${filters.class_name.trim()}%`);\r\n        }\r\n        if (filters.id_number?.trim()) {\r\n            sql += ' AND id_number LIKE ?';\r\n            params.push(`%${filters.id_number.trim()}%`);\r\n        }\r\n        if (filters.mobile_number?.trim()) {\r\n            sql += ' AND mobile_number LIKE ?';\r\n            params.push(`%${filters.mobile_number.trim()}%`);\r\n        }\r\n\r\n        sql += ' LIMIT 20';\r\n\r\n        const stmt = db.prepare(sql);\r\n        const students = stmt.all(...params);\r\n        return { success: true, data: students };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Search failed' };\r\n    }\r\n}\r\n\r\nexport async function createExitPermit(studentId: number, reason: string, authorizer: string) {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            INSERT INTO student_exits (student_id, reason, authorizer)\r\n            VALUES (?, ?, ?)\r\n        `);\r\n        stmt.run(studentId, reason, authorizer);\r\n        revalidatePath('/admin/exit-permit');\r\n        revalidatePath('/guard');\r\n        return { success: true };\r\n    } catch (e) {\r\n        return { success: false, error: 'Failed to create permit' };\r\n    }\r\n}\r\n\r\nexport async function getExitPermits(status = 'PENDING') {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            SELECT e.*, s.name as student_name, s.grade, s.class_name \r\n            FROM student_exits e\r\n            JOIN students s ON e.student_id = s.id\r\n            WHERE e.status = ?\r\n            ORDER BY e.request_time DESC\r\n        `);\r\n        const permits = stmt.all(status);\r\n        return { success: true, data: permits };\r\n    } catch (e) {\r\n        return { success: false, error: 'Fetch failed' };\r\n    }\r\n}\r\n\r\nexport async function confirmExitPermit(id: number) {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            UPDATE student_exits \r\n            SET status = 'EXITED', exit_time = CURRENT_TIMESTAMP\r\n            WHERE id = ?\r\n        `);\r\n        const info = stmt.run(id);\r\n        console.log('Confirm Permit ID:', id, 'Changes:', info.changes);\r\n        if (info.changes === 0) return { success: false, error: 'Permit not found' };\r\n        revalidatePath('/guard');\r\n        revalidatePath('/admin/exit-permit');\r\n        return { success: true };\r\n    } catch (e) {\r\n        return { success: false, error: 'Update failed' };\r\n    }\r\n}\r\n\r\nexport async function getStudentExitReport(date?: string) {\r\n    const targetDate = date || new Date().toISOString().split('T')[0];\r\n    try {\r\n        // Get exits for the day\r\n        const stmt = db.prepare(`\r\n            SELECT e.*, s.name, s.grade, s.class_name, s.id_number\r\n            FROM student_exits e\r\n            JOIN students s ON e.student_id = s.id\r\n            WHERE date(e.exit_time) = ? AND e.status = 'EXITED'\r\n            ORDER BY e.exit_time DESC\r\n        `);\r\n\r\n        const exits = stmt.all(targetDate) as any[];\r\n\r\n        // Calculate cumulative count for each student in the list\r\n        // Could be optimized, but simpler to query individually or group by\r\n\r\n        const exitsWithCount = await Promise.all(exits.map(async (exit) => {\r\n            const countStmt = db.prepare(`\r\n                SELECT COUNT(*) as count FROM student_exits \r\n                WHERE student_id = ? AND status = 'EXITED'\r\n            `);\r\n            const countRes = countStmt.get(exit.student_id) as { count: number };\r\n            return { ...exit, cumulative_count: countRes.count };\r\n        }));\r\n\r\n        return { success: true, data: exitsWithCount };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Report failed' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAwGsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,iDAAA"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/MJD8/OneDrive/Desktop/projects/visit/src/app/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { db } from '@/lib/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function sendOTP(mobileNumber: string) {\r\n    // 1. Generate 4-digit code\r\n    const code = Math.floor(1000 + Math.random() * 9000).toString();\r\n\r\n    // 2. Save to DB with expiration (5 mins)\r\n    const expiresAt = new Date(Date.now() + 5 * 60 * 1000).toISOString();\r\n\r\n    if (process.env.NEXT_PHASE !== 'phase-production-build') {\r\n        const stmt = db.prepare(`\r\n        INSERT OR REPLACE INTO otp_codes (mobile_number, code, expires_at)\r\n        VALUES (?, ?, ?)\r\n      `);\r\n        stmt.run(mobileNumber, code, expiresAt);\r\n    }\r\n\r\n    // 3. Send SMS\r\n    try {\r\n        // Fetch SMS settings from DB\r\n        const settingsStmt = db.prepare(\"SELECT key, value FROM settings WHERE key IN ('sms_api_key', 'sms_sender_name')\");\r\n        const settings = settingsStmt.all() as { key: string; value: string }[];\r\n        const settingsMap = settings.reduce((acc, curr) => ({ ...acc, [curr.key]: curr.value }), {} as Record<string, string>);\r\n\r\n        const apiKey = settingsMap['sms_api_key'] || 'Cg4W16D1N9ckkBXhUafP0gS19XB6ZujmMNC5rtkt1e2e6f1c';\r\n        const senderName = settingsMap['sms_sender_name'] || 'School1';\r\n\r\n        const message = `رمز التحقق: ${code}`;\r\n\r\n        // Format number: remove leading 0, prefix with 966\r\n        // 0501234567 -> 966501234567\r\n        let number = mobileNumber.trim();\r\n        if (number.startsWith('0')) {\r\n            number = '966' + number.substring(1);\r\n        } else if (number.startsWith('5')) {\r\n            number = '966' + number;\r\n        }\r\n\r\n        console.log(`[SMS] Sending to ${number}...`);\r\n\r\n        const response = await fetch('https://app.mobile.net.sa/api/v1/send', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${apiKey}`,\r\n                'Content-Type': 'application/json',\r\n                'Accept': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                number: number,\r\n                senderName: senderName, // Using default/example sender name to ensure delivery\r\n                sendAtOption: \"Now\",\r\n                messageBody: message,\r\n                allow_duplicate: true\r\n            })\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text();\r\n            console.error('SMS API Error:', errorText);\r\n            // Try to parse JSON error if possible\r\n            try {\r\n                const jsonError = JSON.parse(errorText);\r\n                return { success: false, error: `فشل المزود: ${jsonError.message || JSON.stringify(jsonError)}` };\r\n            } catch {\r\n                return { success: false, error: `فشل المزود: ${errorText.substring(0, 100)}` };\r\n            }\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Failed to send SMS:', error);\r\n        return { success: false, error: `فشل إرسال الرسالة: ${error.message}` };\r\n    }\r\n}\r\n\r\nexport async function verifyOTP(mobileNumber: string, code: string) {\r\n    const stmt = db.prepare('SELECT code, expires_at FROM otp_codes WHERE mobile_number = ?');\r\n    const result = stmt.get(mobileNumber) as { code: string; expires_at: string };\r\n\r\n    if (!result) return { success: false, error: 'رقم الجوال غير معروف' };\r\n\r\n    if (result.code !== code) return { success: false, error: 'رمز التحقق غير صحيح' };\r\n\r\n    if (new Date(result.expires_at) < new Date()) {\r\n        return { success: false, error: 'انتهت صلاحية الرمز' };\r\n    }\r\n\r\n    // Clear OTP after success\r\n    db.prepare('DELETE FROM otp_codes WHERE mobile_number = ?').run(mobileNumber);\r\n\r\n    return { success: true };\r\n}\r\n\r\nexport interface VisitorData {\r\n    name: string;\r\n    idNumber: string;\r\n    mobileNumber: string;\r\n    purpose: string;\r\n    signature: string; // Base64\r\n}\r\n\r\nexport async function submitVisitor(data: VisitorData) {\r\n    const stmt = db.prepare(`\r\n    INSERT INTO visitors (name, id_number, mobile_number, visit_date, visit_time, purpose, signature)\r\n    VALUES (?, ?, ?, ?, ?, ?, ?)\r\n  `);\r\n\r\n    const now = new Date();\r\n    const date = now.toISOString().split('T')[0]; // YYYY-MM-DD\r\n    const time = now.toLocaleTimeString('en-US', { hour12: false });\r\n\r\n    try {\r\n        const result = stmt.run(\r\n            data.name,\r\n            data.idNumber,\r\n            data.mobileNumber,\r\n            date,\r\n            time,\r\n            data.purpose,\r\n            data.signature\r\n        );\r\n\r\n        revalidatePath('/');\r\n        return { success: true, id: result.lastInsertRowid };\r\n    } catch (error) {\r\n        console.error('Failed to save visitor:', error);\r\n        return { success: false, error: 'Failed to save data' };\r\n    }\r\n}\r\n\r\nexport async function getVisitors(date?: string) {\r\n    // If no date provided, default to today's date\r\n    const targetDate = date || new Date().toISOString().split('T')[0];\r\n\r\n    try {\r\n        const stmt = db.prepare('SELECT * FROM visitors WHERE visit_date = ? ORDER BY id DESC');\r\n        const visitors = stmt.all(targetDate) as any[]; // Type as needed\r\n        return { success: true, data: visitors };\r\n    } catch (error) {\r\n        console.error('Failed to get visitors:', error);\r\n        return { success: false, error: 'Failed to fetch data' };\r\n    }\r\n}\r\n\r\nexport async function getSchoolInfo() {\r\n    try {\r\n        const keys = ['school_country', 'school_ministry', 'school_directorate', 'school_name', 'sms_api_key', 'sms_sender_name', 'enable_otp'];\r\n        const placeholders = keys.map(() => '?').join(',');\r\n        const stmt = db.prepare(`SELECT key, value FROM settings WHERE key IN (${placeholders})`);\r\n        const results = stmt.all(...keys) as { key: string; value: string }[];\r\n\r\n        const info: Record<string, string> = {};\r\n        results.forEach(r => {\r\n            info[r.key] = r.value;\r\n        });\r\n\r\n        return { success: true, data: info };\r\n    } catch (error) {\r\n        console.error('Failed to get school info:', error);\r\n        return { success: false, error: 'Failed to fetch info' };\r\n    }\r\n}\r\n\r\n// Existing import modification\r\nimport * as XLSX from 'xlsx';\r\n\r\n// ... (keep existing functions, I will just append new ones for now, but better to do it cleanly)\r\n\r\nexport async function importStudents(formData: FormData) {\r\n    const file = formData.get('file') as File;\r\n    if (!file) return { success: false, error: 'No file uploaded' };\r\n\r\n    try {\r\n        const bytes = await file.arrayBuffer();\r\n        const buffer = Buffer.from(bytes);\r\n        const workbook = XLSX.read(buffer, { type: 'buffer' });\r\n        const sheetName = workbook.SheetNames[0];\r\n        const sheet = workbook.Sheets[sheetName];\r\n        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });\r\n\r\n        // Expected columns: Name, Grade, Class, ID Number, Mobile\r\n        // Assuming header row exists, start from index 1. If not, check data.\r\n        // Let's assume row 0 is header.\r\n\r\n        const stmt = db.prepare(`\r\n            INSERT INTO students (name, grade, class_name, id_number, mobile_number)\r\n            VALUES (?, ?, ?, ?, ?)\r\n        `);\r\n\r\n        // Use transaction for bulk insert\r\n        const insertMany = db.transaction((rows) => {\r\n            for (const row of rows) {\r\n                // row is array [Name, Grade, Class, ID, Mobile]\r\n                // Be careful with index if header exists\r\n                if (!row[0] || !row[3]) continue; // Skip empty rows or missing mandatory fields\r\n                try {\r\n                    stmt.run(row[0], row[1], row[2], String(row[3]), String(row[4]));\r\n                } catch (e) {\r\n                    console.log('Skipping duplicate or invalid row:', row);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Skip first row (headers)\r\n        const dataRows = jsonData.slice(1);\r\n        insertMany(dataRows);\r\n\r\n        return { success: true, count: dataRows.length };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Failed to process file' };\r\n    }\r\n}\r\n\r\n// ... (existing code)\r\n\r\nexport async function getAllStudents() {\r\n    try {\r\n        const stmt = db.prepare('SELECT * FROM students ORDER BY grade, class_name, name');\r\n        const students = stmt.all();\r\n        return { success: true, data: students };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Failed to fetch students' };\r\n    }\r\n}\r\n\r\nexport async function searchStudents(filters: { name?: string, grade?: string, class_name?: string, id_number?: string, mobile_number?: string }) {\r\n    try {\r\n        let sql = 'SELECT * FROM students WHERE 1=1';\r\n        const params: any[] = [];\r\n\r\n        if (filters.name?.trim()) {\r\n            sql += ' AND name LIKE ?';\r\n            params.push(`%${filters.name.trim()}%`);\r\n        }\r\n        if (filters.grade?.trim()) {\r\n            sql += ' AND grade LIKE ?';\r\n            params.push(`%${filters.grade.trim()}%`);\r\n        }\r\n        if (filters.class_name?.trim()) {\r\n            sql += ' AND class_name LIKE ?';\r\n            params.push(`%${filters.class_name.trim()}%`);\r\n        }\r\n        if (filters.id_number?.trim()) {\r\n            sql += ' AND id_number LIKE ?';\r\n            params.push(`%${filters.id_number.trim()}%`);\r\n        }\r\n        if (filters.mobile_number?.trim()) {\r\n            sql += ' AND mobile_number LIKE ?';\r\n            params.push(`%${filters.mobile_number.trim()}%`);\r\n        }\r\n\r\n        sql += ' LIMIT 20';\r\n\r\n        const stmt = db.prepare(sql);\r\n        const students = stmt.all(...params);\r\n        return { success: true, data: students };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Search failed' };\r\n    }\r\n}\r\n\r\nexport async function createExitPermit(studentId: number, reason: string, authorizer: string) {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            INSERT INTO student_exits (student_id, reason, authorizer)\r\n            VALUES (?, ?, ?)\r\n        `);\r\n        stmt.run(studentId, reason, authorizer);\r\n        revalidatePath('/admin/exit-permit');\r\n        revalidatePath('/guard');\r\n        return { success: true };\r\n    } catch (e) {\r\n        return { success: false, error: 'Failed to create permit' };\r\n    }\r\n}\r\n\r\nexport async function getExitPermits(status = 'PENDING') {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            SELECT e.*, s.name as student_name, s.grade, s.class_name \r\n            FROM student_exits e\r\n            JOIN students s ON e.student_id = s.id\r\n            WHERE e.status = ?\r\n            ORDER BY e.request_time DESC\r\n        `);\r\n        const permits = stmt.all(status);\r\n        return { success: true, data: permits };\r\n    } catch (e) {\r\n        return { success: false, error: 'Fetch failed' };\r\n    }\r\n}\r\n\r\nexport async function confirmExitPermit(id: number) {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            UPDATE student_exits \r\n            SET status = 'EXITED', exit_time = CURRENT_TIMESTAMP\r\n            WHERE id = ?\r\n        `);\r\n        const info = stmt.run(id);\r\n        console.log('Confirm Permit ID:', id, 'Changes:', info.changes);\r\n        if (info.changes === 0) return { success: false, error: 'Permit not found' };\r\n        revalidatePath('/guard');\r\n        revalidatePath('/admin/exit-permit');\r\n        return { success: true };\r\n    } catch (e) {\r\n        return { success: false, error: 'Update failed' };\r\n    }\r\n}\r\n\r\nexport async function getStudentExitReport(date?: string) {\r\n    const targetDate = date || new Date().toISOString().split('T')[0];\r\n    try {\r\n        // Get exits for the day\r\n        const stmt = db.prepare(`\r\n            SELECT e.*, s.name, s.grade, s.class_name, s.id_number\r\n            FROM student_exits e\r\n            JOIN students s ON e.student_id = s.id\r\n            WHERE date(e.exit_time) = ? AND e.status = 'EXITED'\r\n            ORDER BY e.exit_time DESC\r\n        `);\r\n\r\n        const exits = stmt.all(targetDate) as any[];\r\n\r\n        // Calculate cumulative count for each student in the list\r\n        // Could be optimized, but simpler to query individually or group by\r\n\r\n        const exitsWithCount = await Promise.all(exits.map(async (exit) => {\r\n            const countStmt = db.prepare(`\r\n                SELECT COUNT(*) as count FROM student_exits \r\n                WHERE student_id = ? AND status = 'EXITED'\r\n            `);\r\n            const countRes = countStmt.get(exit.student_id) as { count: number };\r\n            return { ...exit, cumulative_count: countRes.count };\r\n        }));\r\n\r\n        return { success: true, data: exitsWithCount };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Report failed' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAKsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,2CAAA"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/MJD8/OneDrive/Desktop/projects/visit/src/app/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { db } from '@/lib/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function sendOTP(mobileNumber: string) {\r\n    // 1. Generate 4-digit code\r\n    const code = Math.floor(1000 + Math.random() * 9000).toString();\r\n\r\n    // 2. Save to DB with expiration (5 mins)\r\n    const expiresAt = new Date(Date.now() + 5 * 60 * 1000).toISOString();\r\n\r\n    if (process.env.NEXT_PHASE !== 'phase-production-build') {\r\n        const stmt = db.prepare(`\r\n        INSERT OR REPLACE INTO otp_codes (mobile_number, code, expires_at)\r\n        VALUES (?, ?, ?)\r\n      `);\r\n        stmt.run(mobileNumber, code, expiresAt);\r\n    }\r\n\r\n    // 3. Send SMS\r\n    try {\r\n        // Fetch SMS settings from DB\r\n        const settingsStmt = db.prepare(\"SELECT key, value FROM settings WHERE key IN ('sms_api_key', 'sms_sender_name')\");\r\n        const settings = settingsStmt.all() as { key: string; value: string }[];\r\n        const settingsMap = settings.reduce((acc, curr) => ({ ...acc, [curr.key]: curr.value }), {} as Record<string, string>);\r\n\r\n        const apiKey = settingsMap['sms_api_key'] || 'Cg4W16D1N9ckkBXhUafP0gS19XB6ZujmMNC5rtkt1e2e6f1c';\r\n        const senderName = settingsMap['sms_sender_name'] || 'School1';\r\n\r\n        const message = `رمز التحقق: ${code}`;\r\n\r\n        // Format number: remove leading 0, prefix with 966\r\n        // 0501234567 -> 966501234567\r\n        let number = mobileNumber.trim();\r\n        if (number.startsWith('0')) {\r\n            number = '966' + number.substring(1);\r\n        } else if (number.startsWith('5')) {\r\n            number = '966' + number;\r\n        }\r\n\r\n        console.log(`[SMS] Sending to ${number}...`);\r\n\r\n        const response = await fetch('https://app.mobile.net.sa/api/v1/send', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${apiKey}`,\r\n                'Content-Type': 'application/json',\r\n                'Accept': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                number: number,\r\n                senderName: senderName, // Using default/example sender name to ensure delivery\r\n                sendAtOption: \"Now\",\r\n                messageBody: message,\r\n                allow_duplicate: true\r\n            })\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text();\r\n            console.error('SMS API Error:', errorText);\r\n            // Try to parse JSON error if possible\r\n            try {\r\n                const jsonError = JSON.parse(errorText);\r\n                return { success: false, error: `فشل المزود: ${jsonError.message || JSON.stringify(jsonError)}` };\r\n            } catch {\r\n                return { success: false, error: `فشل المزود: ${errorText.substring(0, 100)}` };\r\n            }\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Failed to send SMS:', error);\r\n        return { success: false, error: `فشل إرسال الرسالة: ${error.message}` };\r\n    }\r\n}\r\n\r\nexport async function verifyOTP(mobileNumber: string, code: string) {\r\n    const stmt = db.prepare('SELECT code, expires_at FROM otp_codes WHERE mobile_number = ?');\r\n    const result = stmt.get(mobileNumber) as { code: string; expires_at: string };\r\n\r\n    if (!result) return { success: false, error: 'رقم الجوال غير معروف' };\r\n\r\n    if (result.code !== code) return { success: false, error: 'رمز التحقق غير صحيح' };\r\n\r\n    if (new Date(result.expires_at) < new Date()) {\r\n        return { success: false, error: 'انتهت صلاحية الرمز' };\r\n    }\r\n\r\n    // Clear OTP after success\r\n    db.prepare('DELETE FROM otp_codes WHERE mobile_number = ?').run(mobileNumber);\r\n\r\n    return { success: true };\r\n}\r\n\r\nexport interface VisitorData {\r\n    name: string;\r\n    idNumber: string;\r\n    mobileNumber: string;\r\n    purpose: string;\r\n    signature: string; // Base64\r\n}\r\n\r\nexport async function submitVisitor(data: VisitorData) {\r\n    const stmt = db.prepare(`\r\n    INSERT INTO visitors (name, id_number, mobile_number, visit_date, visit_time, purpose, signature)\r\n    VALUES (?, ?, ?, ?, ?, ?, ?)\r\n  `);\r\n\r\n    const now = new Date();\r\n    const date = now.toISOString().split('T')[0]; // YYYY-MM-DD\r\n    const time = now.toLocaleTimeString('en-US', { hour12: false });\r\n\r\n    try {\r\n        const result = stmt.run(\r\n            data.name,\r\n            data.idNumber,\r\n            data.mobileNumber,\r\n            date,\r\n            time,\r\n            data.purpose,\r\n            data.signature\r\n        );\r\n\r\n        revalidatePath('/');\r\n        return { success: true, id: result.lastInsertRowid };\r\n    } catch (error) {\r\n        console.error('Failed to save visitor:', error);\r\n        return { success: false, error: 'Failed to save data' };\r\n    }\r\n}\r\n\r\nexport async function getVisitors(date?: string) {\r\n    // If no date provided, default to today's date\r\n    const targetDate = date || new Date().toISOString().split('T')[0];\r\n\r\n    try {\r\n        const stmt = db.prepare('SELECT * FROM visitors WHERE visit_date = ? ORDER BY id DESC');\r\n        const visitors = stmt.all(targetDate) as any[]; // Type as needed\r\n        return { success: true, data: visitors };\r\n    } catch (error) {\r\n        console.error('Failed to get visitors:', error);\r\n        return { success: false, error: 'Failed to fetch data' };\r\n    }\r\n}\r\n\r\nexport async function getSchoolInfo() {\r\n    try {\r\n        const keys = ['school_country', 'school_ministry', 'school_directorate', 'school_name', 'sms_api_key', 'sms_sender_name', 'enable_otp'];\r\n        const placeholders = keys.map(() => '?').join(',');\r\n        const stmt = db.prepare(`SELECT key, value FROM settings WHERE key IN (${placeholders})`);\r\n        const results = stmt.all(...keys) as { key: string; value: string }[];\r\n\r\n        const info: Record<string, string> = {};\r\n        results.forEach(r => {\r\n            info[r.key] = r.value;\r\n        });\r\n\r\n        return { success: true, data: info };\r\n    } catch (error) {\r\n        console.error('Failed to get school info:', error);\r\n        return { success: false, error: 'Failed to fetch info' };\r\n    }\r\n}\r\n\r\n// Existing import modification\r\nimport * as XLSX from 'xlsx';\r\n\r\n// ... (keep existing functions, I will just append new ones for now, but better to do it cleanly)\r\n\r\nexport async function importStudents(formData: FormData) {\r\n    const file = formData.get('file') as File;\r\n    if (!file) return { success: false, error: 'No file uploaded' };\r\n\r\n    try {\r\n        const bytes = await file.arrayBuffer();\r\n        const buffer = Buffer.from(bytes);\r\n        const workbook = XLSX.read(buffer, { type: 'buffer' });\r\n        const sheetName = workbook.SheetNames[0];\r\n        const sheet = workbook.Sheets[sheetName];\r\n        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });\r\n\r\n        // Expected columns: Name, Grade, Class, ID Number, Mobile\r\n        // Assuming header row exists, start from index 1. If not, check data.\r\n        // Let's assume row 0 is header.\r\n\r\n        const stmt = db.prepare(`\r\n            INSERT INTO students (name, grade, class_name, id_number, mobile_number)\r\n            VALUES (?, ?, ?, ?, ?)\r\n        `);\r\n\r\n        // Use transaction for bulk insert\r\n        const insertMany = db.transaction((rows) => {\r\n            for (const row of rows) {\r\n                // row is array [Name, Grade, Class, ID, Mobile]\r\n                // Be careful with index if header exists\r\n                if (!row[0] || !row[3]) continue; // Skip empty rows or missing mandatory fields\r\n                try {\r\n                    stmt.run(row[0], row[1], row[2], String(row[3]), String(row[4]));\r\n                } catch (e) {\r\n                    console.log('Skipping duplicate or invalid row:', row);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Skip first row (headers)\r\n        const dataRows = jsonData.slice(1);\r\n        insertMany(dataRows);\r\n\r\n        return { success: true, count: dataRows.length };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Failed to process file' };\r\n    }\r\n}\r\n\r\n// ... (existing code)\r\n\r\nexport async function getAllStudents() {\r\n    try {\r\n        const stmt = db.prepare('SELECT * FROM students ORDER BY grade, class_name, name');\r\n        const students = stmt.all();\r\n        return { success: true, data: students };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Failed to fetch students' };\r\n    }\r\n}\r\n\r\nexport async function searchStudents(filters: { name?: string, grade?: string, class_name?: string, id_number?: string, mobile_number?: string }) {\r\n    try {\r\n        let sql = 'SELECT * FROM students WHERE 1=1';\r\n        const params: any[] = [];\r\n\r\n        if (filters.name?.trim()) {\r\n            sql += ' AND name LIKE ?';\r\n            params.push(`%${filters.name.trim()}%`);\r\n        }\r\n        if (filters.grade?.trim()) {\r\n            sql += ' AND grade LIKE ?';\r\n            params.push(`%${filters.grade.trim()}%`);\r\n        }\r\n        if (filters.class_name?.trim()) {\r\n            sql += ' AND class_name LIKE ?';\r\n            params.push(`%${filters.class_name.trim()}%`);\r\n        }\r\n        if (filters.id_number?.trim()) {\r\n            sql += ' AND id_number LIKE ?';\r\n            params.push(`%${filters.id_number.trim()}%`);\r\n        }\r\n        if (filters.mobile_number?.trim()) {\r\n            sql += ' AND mobile_number LIKE ?';\r\n            params.push(`%${filters.mobile_number.trim()}%`);\r\n        }\r\n\r\n        sql += ' LIMIT 20';\r\n\r\n        const stmt = db.prepare(sql);\r\n        const students = stmt.all(...params);\r\n        return { success: true, data: students };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Search failed' };\r\n    }\r\n}\r\n\r\nexport async function createExitPermit(studentId: number, reason: string, authorizer: string) {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            INSERT INTO student_exits (student_id, reason, authorizer)\r\n            VALUES (?, ?, ?)\r\n        `);\r\n        stmt.run(studentId, reason, authorizer);\r\n        revalidatePath('/admin/exit-permit');\r\n        revalidatePath('/guard');\r\n        return { success: true };\r\n    } catch (e) {\r\n        return { success: false, error: 'Failed to create permit' };\r\n    }\r\n}\r\n\r\nexport async function getExitPermits(status = 'PENDING') {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            SELECT e.*, s.name as student_name, s.grade, s.class_name \r\n            FROM student_exits e\r\n            JOIN students s ON e.student_id = s.id\r\n            WHERE e.status = ?\r\n            ORDER BY e.request_time DESC\r\n        `);\r\n        const permits = stmt.all(status);\r\n        return { success: true, data: permits };\r\n    } catch (e) {\r\n        return { success: false, error: 'Fetch failed' };\r\n    }\r\n}\r\n\r\nexport async function confirmExitPermit(id: number) {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            UPDATE student_exits \r\n            SET status = 'EXITED', exit_time = CURRENT_TIMESTAMP\r\n            WHERE id = ?\r\n        `);\r\n        const info = stmt.run(id);\r\n        console.log('Confirm Permit ID:', id, 'Changes:', info.changes);\r\n        if (info.changes === 0) return { success: false, error: 'Permit not found' };\r\n        revalidatePath('/guard');\r\n        revalidatePath('/admin/exit-permit');\r\n        return { success: true };\r\n    } catch (e) {\r\n        return { success: false, error: 'Update failed' };\r\n    }\r\n}\r\n\r\nexport async function getStudentExitReport(date?: string) {\r\n    const targetDate = date || new Date().toISOString().split('T')[0];\r\n    try {\r\n        // Get exits for the day\r\n        const stmt = db.prepare(`\r\n            SELECT e.*, s.name, s.grade, s.class_name, s.id_number\r\n            FROM student_exits e\r\n            JOIN students s ON e.student_id = s.id\r\n            WHERE date(e.exit_time) = ? AND e.status = 'EXITED'\r\n            ORDER BY e.exit_time DESC\r\n        `);\r\n\r\n        const exits = stmt.all(targetDate) as any[];\r\n\r\n        // Calculate cumulative count for each student in the list\r\n        // Could be optimized, but simpler to query individually or group by\r\n\r\n        const exitsWithCount = await Promise.all(exits.map(async (exit) => {\r\n            const countStmt = db.prepare(`\r\n                SELECT COUNT(*) as count FROM student_exits \r\n                WHERE student_id = ? AND status = 'EXITED'\r\n            `);\r\n            const countRes = countStmt.get(exit.student_id) as { count: number };\r\n            return { ...exit, cumulative_count: countRes.count };\r\n        }));\r\n\r\n        return { success: true, data: exitsWithCount };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Report failed' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MA8EsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,6CAAA"}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/MJD8/OneDrive/Desktop/projects/visit/src/app/actions.ts"],"sourcesContent":["'use server'\r\n\r\nimport { db } from '@/lib/db';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\nexport async function sendOTP(mobileNumber: string) {\r\n    // 1. Generate 4-digit code\r\n    const code = Math.floor(1000 + Math.random() * 9000).toString();\r\n\r\n    // 2. Save to DB with expiration (5 mins)\r\n    const expiresAt = new Date(Date.now() + 5 * 60 * 1000).toISOString();\r\n\r\n    if (process.env.NEXT_PHASE !== 'phase-production-build') {\r\n        const stmt = db.prepare(`\r\n        INSERT OR REPLACE INTO otp_codes (mobile_number, code, expires_at)\r\n        VALUES (?, ?, ?)\r\n      `);\r\n        stmt.run(mobileNumber, code, expiresAt);\r\n    }\r\n\r\n    // 3. Send SMS\r\n    try {\r\n        // Fetch SMS settings from DB\r\n        const settingsStmt = db.prepare(\"SELECT key, value FROM settings WHERE key IN ('sms_api_key', 'sms_sender_name')\");\r\n        const settings = settingsStmt.all() as { key: string; value: string }[];\r\n        const settingsMap = settings.reduce((acc, curr) => ({ ...acc, [curr.key]: curr.value }), {} as Record<string, string>);\r\n\r\n        const apiKey = settingsMap['sms_api_key'] || 'Cg4W16D1N9ckkBXhUafP0gS19XB6ZujmMNC5rtkt1e2e6f1c';\r\n        const senderName = settingsMap['sms_sender_name'] || 'School1';\r\n\r\n        const message = `رمز التحقق: ${code}`;\r\n\r\n        // Format number: remove leading 0, prefix with 966\r\n        // 0501234567 -> 966501234567\r\n        let number = mobileNumber.trim();\r\n        if (number.startsWith('0')) {\r\n            number = '966' + number.substring(1);\r\n        } else if (number.startsWith('5')) {\r\n            number = '966' + number;\r\n        }\r\n\r\n        console.log(`[SMS] Sending to ${number}...`);\r\n\r\n        const response = await fetch('https://app.mobile.net.sa/api/v1/send', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${apiKey}`,\r\n                'Content-Type': 'application/json',\r\n                'Accept': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                number: number,\r\n                senderName: senderName, // Using default/example sender name to ensure delivery\r\n                sendAtOption: \"Now\",\r\n                messageBody: message,\r\n                allow_duplicate: true\r\n            })\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text();\r\n            console.error('SMS API Error:', errorText);\r\n            // Try to parse JSON error if possible\r\n            try {\r\n                const jsonError = JSON.parse(errorText);\r\n                return { success: false, error: `فشل المزود: ${jsonError.message || JSON.stringify(jsonError)}` };\r\n            } catch {\r\n                return { success: false, error: `فشل المزود: ${errorText.substring(0, 100)}` };\r\n            }\r\n        }\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Failed to send SMS:', error);\r\n        return { success: false, error: `فشل إرسال الرسالة: ${error.message}` };\r\n    }\r\n}\r\n\r\nexport async function verifyOTP(mobileNumber: string, code: string) {\r\n    const stmt = db.prepare('SELECT code, expires_at FROM otp_codes WHERE mobile_number = ?');\r\n    const result = stmt.get(mobileNumber) as { code: string; expires_at: string };\r\n\r\n    if (!result) return { success: false, error: 'رقم الجوال غير معروف' };\r\n\r\n    if (result.code !== code) return { success: false, error: 'رمز التحقق غير صحيح' };\r\n\r\n    if (new Date(result.expires_at) < new Date()) {\r\n        return { success: false, error: 'انتهت صلاحية الرمز' };\r\n    }\r\n\r\n    // Clear OTP after success\r\n    db.prepare('DELETE FROM otp_codes WHERE mobile_number = ?').run(mobileNumber);\r\n\r\n    return { success: true };\r\n}\r\n\r\nexport interface VisitorData {\r\n    name: string;\r\n    idNumber: string;\r\n    mobileNumber: string;\r\n    purpose: string;\r\n    signature: string; // Base64\r\n}\r\n\r\nexport async function submitVisitor(data: VisitorData) {\r\n    const stmt = db.prepare(`\r\n    INSERT INTO visitors (name, id_number, mobile_number, visit_date, visit_time, purpose, signature)\r\n    VALUES (?, ?, ?, ?, ?, ?, ?)\r\n  `);\r\n\r\n    const now = new Date();\r\n    const date = now.toISOString().split('T')[0]; // YYYY-MM-DD\r\n    const time = now.toLocaleTimeString('en-US', { hour12: false });\r\n\r\n    try {\r\n        const result = stmt.run(\r\n            data.name,\r\n            data.idNumber,\r\n            data.mobileNumber,\r\n            date,\r\n            time,\r\n            data.purpose,\r\n            data.signature\r\n        );\r\n\r\n        revalidatePath('/');\r\n        return { success: true, id: result.lastInsertRowid };\r\n    } catch (error) {\r\n        console.error('Failed to save visitor:', error);\r\n        return { success: false, error: 'Failed to save data' };\r\n    }\r\n}\r\n\r\nexport async function getVisitors(date?: string) {\r\n    // If no date provided, default to today's date\r\n    const targetDate = date || new Date().toISOString().split('T')[0];\r\n\r\n    try {\r\n        const stmt = db.prepare('SELECT * FROM visitors WHERE visit_date = ? ORDER BY id DESC');\r\n        const visitors = stmt.all(targetDate) as any[]; // Type as needed\r\n        return { success: true, data: visitors };\r\n    } catch (error) {\r\n        console.error('Failed to get visitors:', error);\r\n        return { success: false, error: 'Failed to fetch data' };\r\n    }\r\n}\r\n\r\nexport async function getSchoolInfo() {\r\n    try {\r\n        const keys = ['school_country', 'school_ministry', 'school_directorate', 'school_name', 'sms_api_key', 'sms_sender_name', 'enable_otp'];\r\n        const placeholders = keys.map(() => '?').join(',');\r\n        const stmt = db.prepare(`SELECT key, value FROM settings WHERE key IN (${placeholders})`);\r\n        const results = stmt.all(...keys) as { key: string; value: string }[];\r\n\r\n        const info: Record<string, string> = {};\r\n        results.forEach(r => {\r\n            info[r.key] = r.value;\r\n        });\r\n\r\n        return { success: true, data: info };\r\n    } catch (error) {\r\n        console.error('Failed to get school info:', error);\r\n        return { success: false, error: 'Failed to fetch info' };\r\n    }\r\n}\r\n\r\n// Existing import modification\r\nimport * as XLSX from 'xlsx';\r\n\r\n// ... (keep existing functions, I will just append new ones for now, but better to do it cleanly)\r\n\r\nexport async function importStudents(formData: FormData) {\r\n    const file = formData.get('file') as File;\r\n    if (!file) return { success: false, error: 'No file uploaded' };\r\n\r\n    try {\r\n        const bytes = await file.arrayBuffer();\r\n        const buffer = Buffer.from(bytes);\r\n        const workbook = XLSX.read(buffer, { type: 'buffer' });\r\n        const sheetName = workbook.SheetNames[0];\r\n        const sheet = workbook.Sheets[sheetName];\r\n        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });\r\n\r\n        // Expected columns: Name, Grade, Class, ID Number, Mobile\r\n        // Assuming header row exists, start from index 1. If not, check data.\r\n        // Let's assume row 0 is header.\r\n\r\n        const stmt = db.prepare(`\r\n            INSERT INTO students (name, grade, class_name, id_number, mobile_number)\r\n            VALUES (?, ?, ?, ?, ?)\r\n        `);\r\n\r\n        // Use transaction for bulk insert\r\n        const insertMany = db.transaction((rows) => {\r\n            for (const row of rows) {\r\n                // row is array [Name, Grade, Class, ID, Mobile]\r\n                // Be careful with index if header exists\r\n                if (!row[0] || !row[3]) continue; // Skip empty rows or missing mandatory fields\r\n                try {\r\n                    stmt.run(row[0], row[1], row[2], String(row[3]), String(row[4]));\r\n                } catch (e) {\r\n                    console.log('Skipping duplicate or invalid row:', row);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Skip first row (headers)\r\n        const dataRows = jsonData.slice(1);\r\n        insertMany(dataRows);\r\n\r\n        return { success: true, count: dataRows.length };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Failed to process file' };\r\n    }\r\n}\r\n\r\n// ... (existing code)\r\n\r\nexport async function getAllStudents() {\r\n    try {\r\n        const stmt = db.prepare('SELECT * FROM students ORDER BY grade, class_name, name');\r\n        const students = stmt.all();\r\n        return { success: true, data: students };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Failed to fetch students' };\r\n    }\r\n}\r\n\r\nexport async function searchStudents(filters: { name?: string, grade?: string, class_name?: string, id_number?: string, mobile_number?: string }) {\r\n    try {\r\n        let sql = 'SELECT * FROM students WHERE 1=1';\r\n        const params: any[] = [];\r\n\r\n        if (filters.name?.trim()) {\r\n            sql += ' AND name LIKE ?';\r\n            params.push(`%${filters.name.trim()}%`);\r\n        }\r\n        if (filters.grade?.trim()) {\r\n            sql += ' AND grade LIKE ?';\r\n            params.push(`%${filters.grade.trim()}%`);\r\n        }\r\n        if (filters.class_name?.trim()) {\r\n            sql += ' AND class_name LIKE ?';\r\n            params.push(`%${filters.class_name.trim()}%`);\r\n        }\r\n        if (filters.id_number?.trim()) {\r\n            sql += ' AND id_number LIKE ?';\r\n            params.push(`%${filters.id_number.trim()}%`);\r\n        }\r\n        if (filters.mobile_number?.trim()) {\r\n            sql += ' AND mobile_number LIKE ?';\r\n            params.push(`%${filters.mobile_number.trim()}%`);\r\n        }\r\n\r\n        sql += ' LIMIT 20';\r\n\r\n        const stmt = db.prepare(sql);\r\n        const students = stmt.all(...params);\r\n        return { success: true, data: students };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Search failed' };\r\n    }\r\n}\r\n\r\nexport async function createExitPermit(studentId: number, reason: string, authorizer: string) {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            INSERT INTO student_exits (student_id, reason, authorizer)\r\n            VALUES (?, ?, ?)\r\n        `);\r\n        stmt.run(studentId, reason, authorizer);\r\n        revalidatePath('/admin/exit-permit');\r\n        revalidatePath('/guard');\r\n        return { success: true };\r\n    } catch (e) {\r\n        return { success: false, error: 'Failed to create permit' };\r\n    }\r\n}\r\n\r\nexport async function getExitPermits(status = 'PENDING') {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            SELECT e.*, s.name as student_name, s.grade, s.class_name \r\n            FROM student_exits e\r\n            JOIN students s ON e.student_id = s.id\r\n            WHERE e.status = ?\r\n            ORDER BY e.request_time DESC\r\n        `);\r\n        const permits = stmt.all(status);\r\n        return { success: true, data: permits };\r\n    } catch (e) {\r\n        return { success: false, error: 'Fetch failed' };\r\n    }\r\n}\r\n\r\nexport async function confirmExitPermit(id: number) {\r\n    try {\r\n        const stmt = db.prepare(`\r\n            UPDATE student_exits \r\n            SET status = 'EXITED', exit_time = CURRENT_TIMESTAMP\r\n            WHERE id = ?\r\n        `);\r\n        const info = stmt.run(id);\r\n        console.log('Confirm Permit ID:', id, 'Changes:', info.changes);\r\n        if (info.changes === 0) return { success: false, error: 'Permit not found' };\r\n        revalidatePath('/guard');\r\n        revalidatePath('/admin/exit-permit');\r\n        return { success: true };\r\n    } catch (e) {\r\n        return { success: false, error: 'Update failed' };\r\n    }\r\n}\r\n\r\nexport async function getStudentExitReport(date?: string) {\r\n    const targetDate = date || new Date().toISOString().split('T')[0];\r\n    try {\r\n        // Get exits for the day\r\n        const stmt = db.prepare(`\r\n            SELECT e.*, s.name, s.grade, s.class_name, s.id_number\r\n            FROM student_exits e\r\n            JOIN students s ON e.student_id = s.id\r\n            WHERE date(e.exit_time) = ? AND e.status = 'EXITED'\r\n            ORDER BY e.exit_time DESC\r\n        `);\r\n\r\n        const exits = stmt.all(targetDate) as any[];\r\n\r\n        // Calculate cumulative count for each student in the list\r\n        // Could be optimized, but simpler to query individually or group by\r\n\r\n        const exitsWithCount = await Promise.all(exits.map(async (exit) => {\r\n            const countStmt = db.prepare(`\r\n                SELECT COUNT(*) as count FROM student_exits \r\n                WHERE student_id = ? AND status = 'EXITED'\r\n            `);\r\n            const countRes = countStmt.get(exit.student_id) as { count: number };\r\n            return { ...exit, cumulative_count: countRes.count };\r\n        }));\r\n\r\n        return { success: true, data: exitsWithCount };\r\n    } catch (e) {\r\n        console.error(e);\r\n        return { success: false, error: 'Report failed' };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;MAmJsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA,iDAAA"}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/components/VisitorForm.module.css [app-client] (css module)"],"sourcesContent":["__turbopack_context__.v({\n  \"actions\": \"VisitorForm-module__ZnwAJW__actions\",\n  \"backBtn\": \"VisitorForm-module__ZnwAJW__backBtn\",\n  \"blink\": \"VisitorForm-module__ZnwAJW__blink\",\n  \"blinkingText\": \"VisitorForm-module__ZnwAJW__blinkingText\",\n  \"card\": \"VisitorForm-module__ZnwAJW__card\",\n  \"checkIcon\": \"VisitorForm-module__ZnwAJW__checkIcon\",\n  \"clearBtn\": \"VisitorForm-module__ZnwAJW__clearBtn\",\n  \"fadeIn\": \"VisitorForm-module__ZnwAJW__fadeIn\",\n  \"input\": \"VisitorForm-module__ZnwAJW__input\",\n  \"label\": \"VisitorForm-module__ZnwAJW__label\",\n  \"nextBtn\": \"VisitorForm-module__ZnwAJW__nextBtn\",\n  \"progressBar\": \"VisitorForm-module__ZnwAJW__progressBar\",\n  \"progressFill\": \"VisitorForm-module__ZnwAJW__progressFill\",\n  \"sigCanvas\": \"VisitorForm-module__ZnwAJW__sigCanvas\",\n  \"signatureContainer\": \"VisitorForm-module__ZnwAJW__signatureContainer\",\n  \"slideIn\": \"VisitorForm-module__ZnwAJW__slideIn\",\n  \"stepContainer\": \"VisitorForm-module__ZnwAJW__stepContainer\",\n  \"successCard\": \"VisitorForm-module__ZnwAJW__successCard\",\n});\n"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/MJD8/OneDrive/Desktop/projects/visit/src/components/VisitorForm.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useState, useRef, useEffect } from 'react';\r\nimport SignatureCanvas from 'react-signature-canvas';\r\nimport { submitVisitor, sendOTP, verifyOTP, getSchoolInfo } from '@/app/actions';\r\nimport styles from './VisitorForm.module.css';\r\n\r\nexport default function VisitorForm() {\r\n    const [step, setStep] = useState(0);\r\n    const [formData, setFormData] = useState({\r\n        name: '',\r\n        idNumber: '',\r\n        mobileNumber: '',\r\n        purpose: '',\r\n        acknowledgment: false,\r\n        signature: '',\r\n    });\r\n    const [loading, setLoading] = useState(false);\r\n    const [submitted, setSubmitted] = useState(false);\r\n    const [isVerified, setIsVerified] = useState(false);\r\n    const [otpCode, setOtpCode] = useState('');\r\n    const [showOtpInput, setShowOtpInput] = useState(false);\r\n    const [otpEnabled, setOtpEnabled] = useState(true);\r\n    const [visitorId, setVisitorId] = useState<number | bigint | null>(null);\r\n\r\n    const sigCanvas = useRef<any>(null);\r\n\r\n    const steps = [\r\n        { key: 'name', label: 'اسم الزائر', type: 'text', placeholder: 'أدخل الاسم الثلاثي' },\r\n        { key: 'idNumber', label: 'رقم الهوية / الإقامة', type: 'text', placeholder: 'أدخل رقم الهوية' },\r\n        { key: 'mobileNumber', label: 'رقم الجوال', type: 'tel', placeholder: '05xxxxxxxx' },\r\n        { key: 'purpose', label: 'سبب الزيارة', type: 'text', placeholder: 'اجتماع، توصيل، إلخ' },\r\n        { key: 'acknowledgment', label: 'الإقرار', type: 'checkbox' },\r\n        { key: 'signature', label: 'التوقيع', type: 'signature' },\r\n    ];\r\n\r\n    const currentStep = steps[step];\r\n    const isLastStep = step === steps.length - 1;\r\n\r\n    useEffect(() => {\r\n        getSchoolInfo().then(res => {\r\n            if (res.success && res.data && res.data.enable_otp === 'false') {\r\n                setOtpEnabled(false);\r\n            } else {\r\n                setOtpEnabled(true);\r\n            }\r\n        });\r\n    }, []);\r\n\r\n    // Web OTP API Effect\r\n    useEffect(() => {\r\n        if (!showOtpInput) return;\r\n\r\n        if ('OTPCredential' in window) {\r\n            const ac = new AbortController();\r\n\r\n            // @ts-ignore\r\n            navigator.credentials.get({\r\n                otp: { transport: ['sms'] },\r\n                signal: ac.signal\r\n            } as any).then((otp: any) => {\r\n                setOtpCode(otp.code);\r\n                // Auto verify when code is received\r\n                verifyOTP(formData.mobileNumber, otp.code).then(res => {\r\n                    if (res.success) {\r\n                        setIsVerified(true);\r\n                        setShowOtpInput(false);\r\n                        setStep(prev => prev + 1);\r\n                    } else {\r\n                        alert(res.error || 'رمز التحقق خاطئ');\r\n                    }\r\n                });\r\n            }).catch((err: any) => {\r\n                console.log('Web OTP API error/timeout', err);\r\n            });\r\n\r\n            return () => {\r\n                ac.abort();\r\n            };\r\n        }\r\n    }, [showOtpInput, formData.mobileNumber]);\r\n\r\n    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        const value = e.target.type === 'checkbox' ? e.target.checked : e.target.value;\r\n        setFormData({ ...formData, [currentStep.key]: value });\r\n    };\r\n\r\n    const handleVerify = async () => {\r\n        setLoading(true);\r\n        const res = await verifyOTP(formData.mobileNumber, otpCode);\r\n        setLoading(false);\r\n\r\n        if (res.success) {\r\n            setIsVerified(true);\r\n            setShowOtpInput(false);\r\n            setStep(prev => prev + 1);\r\n        } else {\r\n            alert(res.error || 'رمز التحقق خاطئ');\r\n        }\r\n    };\r\n\r\n    const handleSubmit = async (finalSignature?: string) => {\r\n        setLoading(true);\r\n        try {\r\n            const dataToSubmit = {\r\n                ...formData,\r\n                signature: finalSignature || formData.signature,\r\n            };\r\n\r\n            const res = await submitVisitor(dataToSubmit);\r\n            if (res.success) {\r\n                setVisitorId(res.id as number | bigint);\r\n                setSubmitted(true);\r\n                // Auto-reset removed as per request\r\n            } else {\r\n                alert('حدث خطأ أثناء الحفظ');\r\n            }\r\n        } catch (e) {\r\n            console.error(e);\r\n            alert('حدث خطأ غير متوقع');\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    };\r\n\r\n    const handleNext = async () => {\r\n        if (currentStep.key === 'mobileNumber') {\r\n            if (!formData.mobileNumber) return;\r\n\r\n            if (otpEnabled && !isVerified) {\r\n                if (showOtpInput) {\r\n                    handleVerify();\r\n                    return;\r\n                }\r\n                setLoading(true);\r\n                const res = await sendOTP(formData.mobileNumber);\r\n                setLoading(false);\r\n                if (res.success) {\r\n                    setShowOtpInput(true);\r\n                } else {\r\n                    alert(res.error || 'فشل إرسال الرمز');\r\n                }\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (currentStep.key === 'acknowledgment') {\r\n            if (!formData.acknowledgment) {\r\n                alert('الرجاء الموافقة على الإقرار للمتابعة');\r\n                return;\r\n            }\r\n            setStep(prev => prev + 1);\r\n            return;\r\n        }\r\n\r\n        if (currentStep.type === 'signature') {\r\n            if (sigCanvas.current.isEmpty()) {\r\n                alert('الرجاء التوقيع قبل المتابعة');\r\n                return;\r\n            }\r\n            const signatureData = sigCanvas.current.getTrimmedCanvas().toDataURL('image/png');\r\n            setFormData(prev => ({ ...prev, signature: signatureData }));\r\n            handleSubmit(signatureData);\r\n        } else {\r\n            if (!formData[currentStep.key as keyof typeof formData]) {\r\n                return;\r\n            }\r\n            setStep(prev => prev + 1);\r\n        }\r\n    };\r\n\r\n    const handleClearSignature = () => {\r\n        sigCanvas.current?.clear();\r\n    };\r\n\r\n    if (submitted) {\r\n        return (\r\n            <div className={styles.successCard}>\r\n                <div className={styles.checkIcon}>✓</div>\r\n                <h2>تم التسجيل بنجاح</h2>\r\n                <p style={{ fontSize: '1.2rem', margin: '1rem 0' }}>أهلاً بك، {formData.name}</p>\r\n\r\n                {visitorId && (\r\n                    <div style={{\r\n                        background: 'var(--background)',\r\n                        padding: '1rem',\r\n                        borderRadius: '8px',\r\n                        border: '2px solid var(--primary)',\r\n                        margin: '1rem 0'\r\n                    }}>\r\n                        <p style={{ fontSize: '0.9rem', color: 'var(--text-muted)' }}>رقمك التسلسلي</p>\r\n                        <p style={{ fontSize: '2.5rem', fontWeight: 'bold', color: 'var(--primary)', lineHeight: 1 }}>{visitorId.toString()}</p>\r\n                    </div>\r\n                )}\r\n\r\n                <p className={styles.blinkingText} style={{\r\n                    fontWeight: 'bold',\r\n                    marginTop: '1rem',\r\n                    padding: '0.5rem',\r\n                    borderTop: '1px solid var(--border)'\r\n                }}>\r\n                    الآن يرجى إبراز شاشة جوالك لحارس الأمن\r\n                </p>\r\n\r\n                <button\r\n                    onClick={() => {\r\n                        setSubmitted(false);\r\n                        setStep(0);\r\n                        setFormData({ name: '', idNumber: '', mobileNumber: '', purpose: '', acknowledgment: false, signature: '' });\r\n                        sigCanvas.current?.clear();\r\n                        setVisitorId(null);\r\n                        setIsVerified(false);\r\n                        setOtpCode('');\r\n                        setShowOtpInput(false);\r\n                    }}\r\n                    style={{\r\n                        marginTop: '1.5rem',\r\n                        padding: '0.75rem 1.5rem',\r\n                        background: 'var(--primary)',\r\n                        color: 'white',\r\n                        border: 'none',\r\n                        borderRadius: '8px',\r\n                        cursor: 'pointer',\r\n                        fontWeight: 'bold',\r\n                        fontSize: '1rem',\r\n                        width: '100%'\r\n                    }}\r\n                >\r\n                    تسجيل زائر جديد\r\n                </button>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    return (\r\n        <div className={styles.card}>\r\n            <div className={styles.progressBar}>\r\n                <div\r\n                    className={styles.progressFill}\r\n                    style={{ width: `${((step + 1) / steps.length) * 100}%` }}\r\n                />\r\n            </div>\r\n\r\n            <div className={styles.stepContainer}>\r\n                <h2 className={styles.label}>\r\n                    {showOtpInput ? 'التحقق من رقم الجوال' : currentStep.label}\r\n                </h2>\r\n\r\n                {showOtpInput ? (\r\n                    <div className={styles.otpContainer}>\r\n                        <p style={{ marginBottom: '1rem', color: 'var(--text-muted)' }}>\r\n                            تم إرسال رمز تحقق إلى {formData.mobileNumber}\r\n                        </p>\r\n                        <input\r\n                            autoFocus\r\n                            type=\"text\"\r\n                            autoComplete=\"one-time-code\"\r\n                            inputMode=\"numeric\"\r\n                            maxLength={4}\r\n                            className={styles.input}\r\n                            placeholder=\"أدخل الرمز (4 أرقام)\"\r\n                            value={otpCode}\r\n                            onChange={(e) => setOtpCode(e.target.value)}\r\n                            onKeyDown={(e) => {\r\n                                if (e.key === 'Enter') handleNext();\r\n                            }}\r\n                        />\r\n                    </div>\r\n                ) : currentStep.type === 'checkbox' ? (\r\n                    <div className={styles.checkboxContainer} style={{ marginTop: '1rem' }}>\r\n                        <p style={{\r\n                            fontSize: '0.9rem',\r\n                            color: '#d32f2f',\r\n                            marginBottom: '1.5rem',\r\n                            textAlign: 'right',\r\n                            lineHeight: '1.6',\r\n                            padding: '15px',\r\n                            background: '#ffebee',\r\n                            borderRadius: '8px',\r\n                            border: '1px solid #ffcdd2',\r\n                            fontWeight: 'bold'\r\n                        }}>\r\n                            أقر بالعلم أن عقوبة الاعتداء على المعلم/ـة بأي شكل من أشكال الاعتداء سواءً الاعتداء اللفظي أو الجسدي أو عبر وسائل الإعلام أو التواصل الاجتماعي ؛ يُعاقب المعتدي بغرامة تصل إلى مليون ريال والسجن 10 سنوات , كما أقر بالعلم أنه يُمنع التصوير والتسجيل داخل المباني التعليمية والإدارية التابعة لوزارة التعليم\r\n                        </p>\r\n                        <label style={{ display: 'flex', alignItems: 'center', gap: '10px', cursor: 'pointer', fontSize: '1rem', fontWeight: 'bold' }}>\r\n                            <input\r\n                                type=\"checkbox\"\r\n                                checked={!!formData.acknowledgment}\r\n                                onChange={handleChange}\r\n                                style={{\r\n                                    width: '24px',\r\n                                    height: '24px',\r\n                                    cursor: 'pointer',\r\n                                    accentColor: 'var(--primary)'\r\n                                }}\r\n                            />\r\n                            أتعهد بذلك وأوافق على الإقرار\r\n                        </label>\r\n                    </div>\r\n                ) : currentStep.type === 'signature' ? (\r\n                    <div className={styles.signatureContainer}>\r\n                        <SignatureCanvas\r\n                            ref={sigCanvas}\r\n                            penColor=\"black\"\r\n                            canvasProps={{ className: styles.sigCanvas }}\r\n                        />\r\n                        <button type=\"button\" onClick={handleClearSignature} className={styles.clearBtn}>\r\n                            مسح\r\n                        </button>\r\n                    </div>\r\n                ) : (\r\n                    <>\r\n                        <input\r\n                            autoFocus\r\n                            type={currentStep.type}\r\n                            className={styles.input}\r\n                            placeholder={currentStep.placeholder}\r\n                            value={formData[currentStep.key as keyof typeof formData] as string}\r\n                            onChange={handleChange}\r\n                            onKeyDown={(e) => {\r\n                                if (e.key === 'Enter') handleNext();\r\n                            }}\r\n                        />\r\n                        {currentStep.key === 'mobileNumber' && otpEnabled && !showOtpInput && (\r\n                            <button\r\n                                style={{\r\n                                    marginTop: '1rem',\r\n                                    width: '100%',\r\n                                    padding: '0.75rem',\r\n                                    borderRadius: '8px',\r\n                                    border: 'none',\r\n                                    background: 'var(--primary)',\r\n                                    color: 'white',\r\n                                    fontWeight: 'bold',\r\n                                    cursor: 'pointer'\r\n                                }}\r\n                                onClick={handleNext}\r\n                                disabled={loading || !formData.mobileNumber}\r\n                            >\r\n                                {loading ? 'جاري الإرسال...' : 'إرسال كود التحقق'}\r\n                            </button>\r\n                        )}\r\n                    </>\r\n                )}\r\n            </div>\r\n\r\n            <div className={styles.actions}>\r\n                {step > 0 && !showOtpInput && (\r\n                    <button\r\n                        className={styles.backBtn}\r\n                        onClick={() => setStep(prev => prev - 1)}\r\n                        disabled={loading}\r\n                    >\r\n                        رجوع\r\n                    </button>\r\n                )}\r\n\r\n                {showOtpInput && (\r\n                    <button\r\n                        className={styles.backBtn}\r\n                        onClick={() => setShowOtpInput(false)}\r\n                        disabled={loading}\r\n                    >\r\n                        تغيير الرقم\r\n                    </button>\r\n                )}\r\n\r\n                {!(currentStep.key === 'mobileNumber' && otpEnabled && !showOtpInput) && (\r\n                    <button\r\n                        className={styles.nextBtn}\r\n                        onClick={handleNext}\r\n                        disabled={loading || (!showOtpInput && currentStep.type !== 'signature' && !formData[currentStep.key as keyof typeof formData])}\r\n                    >\r\n                        {showOtpInput ? (loading ? 'جاري التحقق...' : 'تحقق') :\r\n                            isLastStep ? (loading ? 'جاري الحفظ...' : 'إنهاء') : 'التالي'}\r\n                    </button>\r\n                )}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n"],"names":[],"mappings":"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"}}]
}